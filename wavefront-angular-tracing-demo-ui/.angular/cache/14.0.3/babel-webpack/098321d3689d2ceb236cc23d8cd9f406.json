{"ast":null,"code":"import os from 'os';\nimport url from 'url';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar None = {\n  get type() {\n    return 'None';\n  },\n\n  get present() {\n    return false;\n  },\n\n  map: function map() {\n    return this;\n  },\n  ifPresent: function ifPresent() {},\n  flatMap: function flatMap() {\n    return this;\n  },\n  getOrElse: function getOrElse(f) {\n    return f instanceof Function ? f() : f;\n  },\n  equals: function equals(other) {\n    return other === this;\n  },\n  toString: function toString() {\n    return 'None';\n  }\n};\n\nvar Some = /*#__PURE__*/function () {\n  function Some(value) {\n    _classCallCheck(this, Some);\n\n    this.value = value;\n  }\n\n  _createClass(Some, [{\n    key: \"map\",\n    value: function map(f) {\n      return new Some(f(this.value));\n    }\n  }, {\n    key: \"ifPresent\",\n    value: function ifPresent(f) {\n      f(this.value);\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(f) {\n      return f(this.value);\n    }\n  }, {\n    key: \"getOrElse\",\n    value: function getOrElse() {\n      return this.value;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other instanceof Some && other.value === this.value;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Some(\".concat(this.value, \")\");\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      // eslint-disable-line class-methods-use-this\n      return 'Some';\n    }\n  }, {\n    key: \"present\",\n    get: function get() {\n      // eslint-disable-line class-methods-use-this\n      return true;\n    }\n  }]);\n\n  return Some;\n}(); // Used to validate input arguments\n\n\nfunction isOptional(data) {\n  return data instanceof Some || None.equals(data);\n}\n\nfunction verifyIsOptional(data) {\n  if (data == null) {\n    throw new Error('Error: data is not Optional - it\\'s null');\n  }\n\n  if (isOptional(data)) {\n    if (isOptional(data.value)) {\n      throw new Error(\"Error: data (\".concat(data.value, \") is wrapped in Option twice\"));\n    }\n  } else {\n    throw new Error(\"Error: data (\".concat(data, \") is not an Option!\"));\n  }\n}\n\nfunction verifyIsNotOptional(data) {\n  if (isOptional(data)) {\n    throw new Error(\"Error: data (\".concat(data, \") is an Option!\"));\n  }\n}\n\nfunction fromNullable(nullable) {\n  return nullable == null ? None : new Some(nullable);\n}\n\nvar Some_1 = Some;\nvar None_1 = None;\nvar isOptional_1 = isOptional;\nvar verifyIsOptional_1 = verifyIsOptional;\nvar verifyIsNotOptional_1 = verifyIsNotOptional;\nvar fromNullable_1 = fromNullable;\nvar option = {\n  Some: Some_1,\n  None: None_1,\n  isOptional: isOptional_1,\n  verifyIsOptional: verifyIsOptional_1,\n  verifyIsNotOptional: verifyIsNotOptional_1,\n  fromNullable: fromNullable_1\n};\n\nfunction pickInterface(interfaces, family) {\n  /* eslint-disable */\n  for (var i in interfaces) {\n    /* eslint-enable */\n    for (var j = interfaces[i].length - 1; j >= 0; j -= 1) {\n      var face = interfaces[i][j];\n      var reachable = family === 'IPv4' || face.scopeid === 0;\n      if (!face.internal && face.family === family && reachable) return face.address;\n    }\n  }\n\n  return family === 'IPv4' ? '127.0.0.1' : '::1';\n}\n\nfunction reduceInterfaces(interfaces, iface) {\n  var ifaces = {};\n  /*eslint-disable */\n\n  for (var i in interfaces) {\n    /* eslint-enable */\n    if (i === iface) ifaces[i] = interfaces[i];\n  }\n\n  return ifaces;\n}\n\nfunction ipv4(iface) {\n  var interfaces = os.networkInterfaces();\n  if (iface) interfaces = reduceInterfaces(interfaces, iface);\n  return pickInterface(interfaces, 'IPv4');\n}\n\nfunction ipv6(iface) {\n  var interfaces = os.networkInterfaces();\n  if (iface) interfaces = reduceInterfaces(interfaces, iface);\n  return pickInterface(interfaces, 'IPv6');\n}\n\nipv4.ipv4 = ipv4;\nipv4.ipv6 = ipv6;\nvar network = ipv4;\n\nvar InetAddress = /*#__PURE__*/function () {\n  function InetAddress(addr) {\n    _classCallCheck(this, InetAddress);\n\n    this.addr = addr;\n  } // returns undefined if this isn't an IPv4 string\n\n\n  _createClass(InetAddress, [{\n    key: \"ipv4\",\n    value: function ipv4() {\n      // coercing to int forces validation here\n      var ipv4Int = this.toInt();\n\n      if (ipv4Int && ipv4Int !== 0) {\n        return this.addr;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"toInt\",\n    value: function toInt() {\n      // e.g. 10.57.50.83\n      // should become\n      // 171520595\n      var parts = this.addr.split('.'); // The eslint tool always complains about using bitwise operators,\n      // but in this case it's actually intentional, so we disable the warning:\n\n      /* eslint-disable-next-line */\n\n      return parts[0] << 24 | parts[1] << 16 | parts[2] << 8 | parts[3];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"InetAddress(\".concat(this.addr, \")\");\n    }\n  }]);\n\n  return InetAddress;\n}(); // In non-node environments we fallback to 127.0.0.1\n\n\nfunction getLocalAddress() {\n  var isNode = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && typeof process.on === 'function';\n\n  if (!isNode) {\n    return new InetAddress('127.0.0.1');\n  } // eslint-disable-next-line global-require\n\n\n  var networkAddress = network;\n  return new InetAddress(networkAddress.ipv4());\n} // Cache this value at import time so as to avoid network interface\n// lookup on every call\n\n\nvar cachedLocalAddress = getLocalAddress();\n\nInetAddress.getLocalAddress = function () {\n  return cachedLocalAddress;\n};\n\nvar InetAddress_1 = InetAddress;\n\nvar SimpleAnnotation = /*#__PURE__*/function () {\n  function SimpleAnnotation() {\n    _classCallCheck(this, SimpleAnnotation);\n  }\n\n  _createClass(SimpleAnnotation, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.annotationType, \"()\");\n    }\n  }]);\n\n  return SimpleAnnotation;\n}();\n\nvar ClientSend = /*#__PURE__*/function (_SimpleAnnotation) {\n  _inherits(ClientSend, _SimpleAnnotation);\n\n  var _super = _createSuper(ClientSend);\n\n  function ClientSend() {\n    _classCallCheck(this, ClientSend);\n\n    return _super.apply(this, arguments);\n  }\n\n  return ClientSend;\n}(SimpleAnnotation);\n\nvar ClientRecv = /*#__PURE__*/function (_SimpleAnnotation2) {\n  _inherits(ClientRecv, _SimpleAnnotation2);\n\n  var _super2 = _createSuper(ClientRecv);\n\n  function ClientRecv() {\n    _classCallCheck(this, ClientRecv);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return ClientRecv;\n}(SimpleAnnotation);\n\nvar ServerSend = /*#__PURE__*/function (_SimpleAnnotation3) {\n  _inherits(ServerSend, _SimpleAnnotation3);\n\n  var _super3 = _createSuper(ServerSend);\n\n  function ServerSend() {\n    _classCallCheck(this, ServerSend);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return ServerSend;\n}(SimpleAnnotation);\n\nvar ServerRecv = /*#__PURE__*/function (_SimpleAnnotation4) {\n  _inherits(ServerRecv, _SimpleAnnotation4);\n\n  var _super4 = _createSuper(ServerRecv);\n\n  function ServerRecv() {\n    _classCallCheck(this, ServerRecv);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return ServerRecv;\n}(SimpleAnnotation);\n\nvar ProducerStart = /*#__PURE__*/function (_SimpleAnnotation5) {\n  _inherits(ProducerStart, _SimpleAnnotation5);\n\n  var _super5 = _createSuper(ProducerStart);\n\n  function ProducerStart() {\n    _classCallCheck(this, ProducerStart);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return ProducerStart;\n}(SimpleAnnotation);\n\nvar ProducerStop = /*#__PURE__*/function (_SimpleAnnotation6) {\n  _inherits(ProducerStop, _SimpleAnnotation6);\n\n  var _super6 = _createSuper(ProducerStop);\n\n  function ProducerStop() {\n    _classCallCheck(this, ProducerStop);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return ProducerStop;\n}(SimpleAnnotation);\n\nvar ConsumerStart = /*#__PURE__*/function (_SimpleAnnotation7) {\n  _inherits(ConsumerStart, _SimpleAnnotation7);\n\n  var _super7 = _createSuper(ConsumerStart);\n\n  function ConsumerStart() {\n    _classCallCheck(this, ConsumerStart);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return ConsumerStart;\n}(SimpleAnnotation);\n\nvar ConsumerStop = /*#__PURE__*/function (_SimpleAnnotation8) {\n  _inherits(ConsumerStop, _SimpleAnnotation8);\n\n  var _super8 = _createSuper(ConsumerStop);\n\n  function ConsumerStop() {\n    _classCallCheck(this, ConsumerStop);\n\n    return _super8.apply(this, arguments);\n  }\n\n  return ConsumerStop;\n}(SimpleAnnotation);\n\nfunction LocalOperationStart(name) {\n  this.name = name;\n}\n\nLocalOperationStart.prototype.toString = function () {\n  return \"LocalOperationStart(\\\"\".concat(this.name, \"\\\")\");\n};\n\nvar LocalOperationStop = /*#__PURE__*/function (_SimpleAnnotation9) {\n  _inherits(LocalOperationStop, _SimpleAnnotation9);\n\n  var _super9 = _createSuper(LocalOperationStop);\n\n  function LocalOperationStop() {\n    _classCallCheck(this, LocalOperationStop);\n\n    return _super9.apply(this, arguments);\n  }\n\n  return LocalOperationStop;\n}(SimpleAnnotation);\n\nfunction Message(message) {\n  this.message = message;\n}\n\nMessage.prototype.toString = function () {\n  return \"Message(\\\"\".concat(this.message, \"\\\")\");\n};\n\nfunction ServiceName(serviceName) {\n  this.serviceName = serviceName;\n}\n\nServiceName.prototype.toString = function () {\n  return \"ServiceName(\\\"\".concat(this.serviceName, \"\\\")\");\n};\n\nfunction Rpc(name) {\n  this.name = name;\n}\n\nRpc.prototype.toString = function () {\n  return \"Rpc(\\\"\".concat(this.name, \"\\\")\");\n};\n\nfunction ClientAddr(_ref) {\n  var host = _ref.host,\n      port = _ref.port;\n  this.host = host;\n  this.port = port;\n}\n\nClientAddr.prototype.toString = function () {\n  return \"ClientAddr(host=\\\"\".concat(this.host, \"\\\", port=\").concat(this.port, \")\");\n};\n\nfunction ServerAddr(_ref2) {\n  var serviceName = _ref2.serviceName,\n      host = _ref2.host,\n      port = _ref2.port;\n  this.serviceName = serviceName;\n  this.host = host || undefined;\n  this.port = port || 0;\n}\n\nServerAddr.prototype.toString = function () {\n  return \"ServerAddr(serviceName=\\\"\".concat(this.serviceName, \"\\\", host=\\\"\").concat(this.host, \"\\\", port=\").concat(this.port, \")\");\n};\n\nfunction LocalAddr(_ref3) {\n  var host = _ref3.host,\n      port = _ref3.port;\n  this.host = host || InetAddress_1.getLocalAddress();\n  this.port = port || 0;\n}\n\nLocalAddr.prototype.toString = function () {\n  return \"LocalAddr(host=\\\"\".concat(this.host.toString(), \"\\\", port=\").concat(this.port, \")\");\n};\n\nfunction MessageAddr(_ref4) {\n  var serviceName = _ref4.serviceName,\n      host = _ref4.host,\n      port = _ref4.port;\n  this.serviceName = serviceName;\n  this.host = host;\n  this.port = port;\n}\n\nMessageAddr.prototype.toString = function () {\n  return \"MessageAddr(serviceName=\\\"\".concat(this.serviceName, \"\\\", host=\\\"\").concat(this.host, \"\\\", port=\").concat(this.port, \")\");\n};\n\nfunction BinaryAnnotation(key, value) {\n  this.key = key;\n  this.value = value;\n}\n\nBinaryAnnotation.prototype.toString = function () {\n  return \"BinaryAnnotation(\".concat(this.key, \"=\\\"\").concat(this.value, \"\\\")\");\n};\n\nvar annotation = {\n  ClientSend: ClientSend,\n  ClientRecv: ClientRecv,\n  ServerSend: ServerSend,\n  ServerRecv: ServerRecv,\n  ProducerStart: ProducerStart,\n  ProducerStop: ProducerStop,\n  ConsumerStart: ConsumerStart,\n  ConsumerStop: ConsumerStop,\n  MessageAddr: MessageAddr,\n  Message: Message,\n  ServiceName: ServiceName,\n  Rpc: Rpc,\n  ClientAddr: ClientAddr,\n  ServerAddr: ServerAddr,\n  LocalAddr: LocalAddr,\n  BinaryAnnotation: BinaryAnnotation,\n  LocalOperationStart: LocalOperationStart,\n  LocalOperationStop: LocalOperationStop\n};\nObject.keys(annotation).forEach(function (key) {\n  annotation[key].prototype.annotationType = key;\n});\nvar annotation_1 = annotation;\nvar isPromise_1 = isPromise;\nvar default_1 = isPromise;\n\nfunction isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n\nisPromise_1.default = default_1;\nvar Some$1 = option.Some; // Determines whether or not a traceId should be sampled.\n// If no sample decision is already made (by a debug flag, or\n// the \"sampled\" property is set), it will use evaluator,\n// which is a function traceId => Boolean, and returns true if\n// the traceId should be sampled (stored in Zipkin).\n\nvar Sampler = /*#__PURE__*/function () {\n  function Sampler(evaluator) {\n    _classCallCheck(this, Sampler);\n\n    this.evaluator = evaluator;\n  }\n\n  _createClass(Sampler, [{\n    key: \"shouldSample\",\n    value: function shouldSample(traceId) {\n      var _this = this;\n\n      var result = traceId.sampled.getOrElse(function () {\n        return _this.evaluator(traceId);\n      });\n      return new Some$1(result);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Sampler(\".concat(this.evaluator.toString(), \")\");\n    }\n  }]);\n\n  return Sampler;\n}();\n\nfunction neverSample(traceId) {\n  // eslint-disable-line no-unused-vars\n  return false;\n}\n\nneverSample.toString = function () {\n  return 'never sample';\n};\n\nfunction alwaysSample(traceId) {\n  // eslint-disable-line no-unused-vars\n  return true;\n}\n\nalwaysSample.toString = function () {\n  return 'always sample';\n};\n\nfunction makeCountingEvaluator(sampleRate) {\n  if (sampleRate <= 0) {\n    return neverSample;\n  } else if (sampleRate >= 1) {\n    return alwaysSample;\n  } else {\n    var counter = 0;\n    var limit = parseInt(1 / sampleRate);\n\n    var counting = function counting(traceId) {\n      // eslint-disable-line no-unused-vars\n      counter %= limit;\n      var shouldSample = counter === 0;\n      counter += 1;\n      return shouldSample;\n    };\n\n    counting.toString = function () {\n      return \"countingSampler: sampleRate=\".concat(sampleRate);\n    };\n\n    return counting;\n  }\n}\n\nvar CountingSampler = /*#__PURE__*/function (_Sampler) {\n  _inherits(CountingSampler, _Sampler);\n\n  var _super = _createSuper(CountingSampler);\n\n  function CountingSampler() {\n    var sampleRate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    _classCallCheck(this, CountingSampler);\n\n    return _super.call(this, makeCountingEvaluator(sampleRate < 1 ? sampleRate : 1));\n  }\n\n  return CountingSampler;\n}(Sampler);\n\nvar sampler = {\n  Sampler: Sampler,\n  CountingSampler: CountingSampler,\n  neverSample: neverSample,\n  alwaysSample: alwaysSample\n};\n\nvar Record = /*#__PURE__*/function () {\n  function Record(_ref) {\n    var traceId = _ref.traceId,\n        timestamp = _ref.timestamp,\n        annotation = _ref.annotation;\n\n    _classCallCheck(this, Record);\n\n    this.traceId = traceId;\n    this.timestamp = timestamp;\n    this.annotation = annotation;\n  }\n\n  _createClass(Record, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"Record(traceId=\".concat(this.traceId.toString(), \", annotation=\").concat(this.annotation.toString(), \")\");\n    }\n  }]);\n\n  return Record;\n}();\n\nvar record = Record;\nvar Some$2 = option.Some,\n    None$1 = option.None,\n    verifyIsOptional$1 = option.verifyIsOptional,\n    verifyIsNotOptional$1 = option.verifyIsNotOptional,\n    isOptional$1 = option.isOptional;\nvar T = new Some$2(true);\n\nvar TraceId = /*#__PURE__*/function () {\n  function TraceId(params) {\n    _classCallCheck(this, TraceId);\n\n    var spanId = params.spanId,\n        _params$traceId = params.traceId,\n        traceId = _params$traceId === void 0 ? spanId : _params$traceId,\n        _params$parentId = params.parentId,\n        parentId = _params$parentId === void 0 ? None$1 : _params$parentId,\n        _params$flags = params.flags,\n        flags = _params$flags === void 0 ? 0 : _params$flags,\n        _params$debug = params.debug,\n        debug = _params$debug === void 0 ? flags === 1 : _params$debug,\n        _params$sampled = params.sampled,\n        sampled = _params$sampled === void 0 ? None$1 : _params$sampled,\n        _params$shared = params.shared,\n        shared = _params$shared === void 0 ? false : _params$shared;\n    verifyIsNotOptional$1(spanId);\n    verifyIsOptional$1(parentId);\n    verifyIsOptional$1(sampled); // support old signatures which allowed traceId to be optional\n\n    if (isOptional$1(traceId)) {\n      this._traceId = traceId.getOrElse(spanId);\n    } else if (typeof traceId === 'undefined' || traceId === null) {\n      this._traceId = spanId;\n    } else {\n      this._traceId = traceId;\n    }\n\n    this._parentId = parentId;\n    this._spanId = spanId;\n    this._sampled = debug ? T : sampled;\n    this._debug = debug;\n    this._shared = shared;\n  }\n\n  _createClass(TraceId, [{\n    key: \"isDebug\",\n    value: function isDebug() {\n      return this._debug;\n    }\n  }, {\n    key: \"isShared\",\n    value: function isShared() {\n      return this._shared;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"TraceId(spanId=\".concat(this.spanId.toString()) + \", parentSpanId=\".concat(this.parentSpanId.toString()) + \", traceId=\".concat(this.traceId.toString(), \")\");\n    }\n  }, {\n    key: \"traceId\",\n    get: function get() {\n      return this._traceId;\n    }\n  }, {\n    key: \"parentSpanId\",\n    get: function get() {\n      return this._parentId;\n    }\n    /**\n     * Please use parentSpanId instead as this can return confusing results (the span ID when absent).\n     *\n     * @deprecated since version v0.19\n     */\n\n  }, {\n    key: \"parentId\",\n    get: function get() {\n      return this._parentId.getOrElse(this._spanId);\n    }\n  }, {\n    key: \"spanId\",\n    get: function get() {\n      return this._spanId;\n    }\n  }, {\n    key: \"sampled\",\n    get: function get() {\n      return this._sampled;\n    }\n    /**\n     * Please use isDebug instead.\n     *\n     * @deprecated since version v0.19\n     */\n\n  }, {\n    key: \"flags\",\n    get: function get() {\n      return this._debug ? 1 : 0;\n    }\n  }]);\n\n  return TraceId;\n}();\n\nvar TraceId_1 = TraceId; // === Generate a random 64-bit number in fixed-length hex format\n\nfunction randomTraceId() {\n  var digits = '0123456789abcdef';\n  var n = '';\n\n  for (var i = 0; i < 16; i += 1) {\n    var rand = Math.floor(Math.random() * 16);\n    n += digits[rand];\n  }\n\n  return n;\n}\n\nvar randomTraceId_1 = randomTraceId;\nvar hrTimeSupport = typeof process !== 'undefined' && process.hrtime; // since hrtime isn't available, we can ignore the input parameters\n\nfunction nowLegacy() {\n  return Date.now() * 1000;\n}\n\nfunction nowHrTime(startTimestamp, startTick) {\n  if (startTimestamp && startTick) {\n    var _hrtime = process.hrtime(startTick);\n\n    var elapsedMicros = Math.floor(_hrtime[0] * 1000000 + _hrtime[1] / 1000);\n    return startTimestamp + elapsedMicros;\n  } else {\n    return Date.now() * 1000;\n  }\n} // Returns the current time in epoch microseconds\n// if startTimestamp and startTick are present, process.hrtime is used\n// See https://nodejs.org/api/process.html#process_process_hrtime_time\n\n\nvar now = hrTimeSupport ? nowHrTime : nowLegacy;\nvar hrtime = hrTimeSupport ? function () {\n  return process.hrtime();\n} : function () {\n  return undefined;\n};\nvar time = {\n  now: now,\n  hrtime: hrtime\n};\n\nfunction Endpoint(_ref) {\n  var serviceName = _ref.serviceName,\n      ipv4 = _ref.ipv4,\n      port = _ref.port;\n  this.setServiceName(serviceName);\n  this.setIpv4(ipv4);\n  this.setPort(port);\n}\n\nEndpoint.prototype.setServiceName = function setServiceName(serviceName) {\n  // In zipkin, names are lowercase. This eagerly converts to alert users early.\n  this.serviceName = serviceName ? serviceName.toLocaleLowerCase() : undefined;\n};\n\nEndpoint.prototype.setIpv4 = function setIpv4(ipv4) {\n  this.ipv4 = ipv4;\n};\n\nEndpoint.prototype.setPort = function setPort(port) {\n  this.port = port || undefined;\n};\n\nEndpoint.prototype.isEmpty = function isEmpty() {\n  return this.serviceName === undefined && this.ipv4 === undefined && this.port === undefined;\n};\n\nfunction Annotation(timestamp, value) {\n  this.timestamp = timestamp;\n  this.value = value.toString();\n}\n\nAnnotation.prototype.toString = function toString() {\n  return \"Annotation(value=\\\"\".concat(this.value, \"\\\")\");\n};\n\nfunction Span(traceId) {\n  var _this = this;\n\n  this.traceId = traceId.traceId;\n  traceId.parentSpanId.ifPresent(function (id) {\n    _this.parentId = id;\n  });\n  this.id = traceId.spanId;\n  this.name = undefined; // no default\n\n  this.kind = undefined; // no default\n\n  this.timestamp = undefined;\n  this.duration = undefined;\n  this.localEndpoint = undefined; // no default\n\n  this.remoteEndpoint = undefined; // no default\n\n  this.annotations = [];\n  this.tags = {};\n  this.debug = traceId.isDebug();\n  this.shared = traceId.isShared();\n}\n\nSpan.prototype.setName = function setName(name) {\n  // In zipkin, names are lowercase. This eagerly converts to alert users early.\n  this.name = name ? name.toLocaleLowerCase() : undefined;\n};\n\nSpan.prototype.setKind = function setKind(kind) {\n  this.kind = kind;\n};\n\nSpan.prototype.setTimestamp = function setTimestamp(timestamp) {\n  this.timestamp = timestamp;\n};\n\nSpan.prototype.setDuration = function setDuration(duration) {\n  // Due to rounding errors, a fraction ends up as zero, so check undefined\n  if (typeof duration !== 'undefined') {\n    this.duration = Math.max(duration, 1);\n  }\n};\n\nSpan.prototype.setLocalEndpoint = function setLocalEndpoint(ep) {\n  if (ep && !ep.isEmpty()) {\n    this.localEndpoint = ep;\n  } else {\n    this.localEndpoint = undefined;\n  }\n};\n\nSpan.prototype.setRemoteEndpoint = function setRemoteEndpoint(ep) {\n  if (ep && !ep.isEmpty()) {\n    this.remoteEndpoint = ep;\n  } else {\n    this.remoteEndpoint = undefined;\n  }\n};\n\nSpan.prototype.addAnnotation = function addAnnotation(timestamp, value) {\n  this.annotations.push(new Annotation(timestamp, value));\n};\n\nSpan.prototype.putTag = function putTag(key, value) {\n  this.tags[key] = value.toString();\n};\n\nSpan.prototype.setDebug = function setDebug(debug) {\n  this.debug = debug;\n};\n\nSpan.prototype.setShared = function setShared(shared) {\n  this.shared = shared;\n};\n\nSpan.prototype.toString = function toString() {\n  var annotations = this.annotations.map(function (a) {\n    return a.toString();\n  }).join(', ');\n  return \"Span(id=\".concat(this.traceId, \", annotations=[\").concat(annotations, \"])\");\n};\n\nvar Endpoint_1 = Endpoint;\nvar Span_1 = Span;\nvar model = {\n  Endpoint: Endpoint_1,\n  Span: Span_1\n};\nvar None$2 = option.None,\n    Some$3 = option.Some;\nvar Sampler$1 = sampler.Sampler,\n    alwaysSample$1 = sampler.alwaysSample;\nvar now$1 = time.now,\n    hrtime$1 = time.hrtime;\nvar Endpoint$1 = model.Endpoint;\n\nfunction requiredArg(name) {\n  throw new Error(\"Tracer: Missing required argument \".concat(name, \".\"));\n}\n\nfunction isUndefinedOrNull(obj) {\n  return typeof obj === 'undefined' || obj === null;\n}\n\nvar Tracer = /*#__PURE__*/function () {\n  function Tracer(_ref) {\n    var _ref$ctxImpl = _ref.ctxImpl,\n        ctxImpl = _ref$ctxImpl === void 0 ? requiredArg('ctxImpl') : _ref$ctxImpl,\n        _ref$recorder = _ref.recorder,\n        recorder = _ref$recorder === void 0 ? requiredArg('recorder') : _ref$recorder,\n        _ref$sampler = _ref.sampler,\n        sampler$$1 = _ref$sampler === void 0 ? new Sampler$1(alwaysSample$1) : _ref$sampler,\n        _ref$traceId128Bit = _ref.traceId128Bit,\n        traceId128Bit = _ref$traceId128Bit === void 0 ? false : _ref$traceId128Bit,\n        _ref$supportsJoin = _ref.supportsJoin,\n        supportsJoin = _ref$supportsJoin === void 0 ? true : _ref$supportsJoin,\n        localServiceName = _ref.localServiceName,\n        localEndpoint = _ref.localEndpoint,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? console : _ref$log,\n        defaultTags = _ref.defaultTags;\n\n    _classCallCheck(this, Tracer);\n\n    this.log = log;\n    this.recorder = recorder;\n    this.sampler = sampler$$1;\n    this.traceId128Bit = traceId128Bit;\n    this.supportsJoin = supportsJoin;\n\n    if (localEndpoint) {\n      this._localEndpoint = localEndpoint;\n    } else {\n      this._localEndpoint = new Endpoint$1({\n        serviceName: localServiceName || 'unknown'\n      });\n    }\n\n    this._ctxImpl = ctxImpl; // The sentinel is used until there's a trace ID in scope.\n    // Technically, this ID should have been unsampled, but it can break code to change that now.\n\n    this._sentinelTraceId = this.createRootId();\n    this._startTimestamp = now$1();\n    this._startTick = hrtime$1(); // only set defaultTags in recorders which know about it\n\n    if (this.recorder.setDefaultTags) {\n      this.recorder.setDefaultTags(defaultTags);\n    }\n  }\n\n  _createClass(Tracer, [{\n    key: \"scoped\",\n    value: function scoped(callback) {\n      return this._ctxImpl.scoped(callback);\n    }\n  }, {\n    key: \"letId\",\n    value: function letId(id, callback) {\n      return this._ctxImpl.letContext(id, callback);\n    }\n  }, {\n    key: \"createRootId\",\n    value: function createRootId() {\n      var isSampled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : None$2;\n      var isDebug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var rootSpanId = randomTraceId_1();\n      var traceId = this.traceId128Bit ? randomTraceId_1() + rootSpanId : rootSpanId;\n      var id = new TraceId_1({\n        traceId: traceId,\n        parentId: None$2,\n        spanId: rootSpanId,\n        sampled: isSampled,\n        flags: isDebug ? 1 : 0\n      });\n\n      if (isSampled === None$2) {\n        id._sampled = this.sampler.shouldSample(id);\n      }\n\n      return id;\n    }\n  }, {\n    key: \"createChildId\",\n    value: function createChildId(parentId) {\n      if (isUndefinedOrNull(parentId)) {\n        /* eslint-disable no-param-reassign */\n        parentId = this._ctxImpl.getContext();\n      }\n\n      if (parentId === this._sentinelTraceId || isUndefinedOrNull(parentId)) {\n        return this.createRootId();\n      }\n\n      var childId = new TraceId_1({\n        traceId: parentId.traceId,\n        parentId: new Some$3(parentId.spanId),\n        spanId: randomTraceId_1(),\n        debug: parentId.isDebug(),\n        sampled: parentId.sampled\n      });\n\n      if (childId.sampled.present === false) {\n        childId._sampled = this.sampler.shouldSample(childId);\n      }\n\n      return childId;\n    } // this allows you to avoid use of implicit trace ID and defer implicit timestamp derivation\n\n  }, {\n    key: \"_explicitRecord\",\n    value: function _explicitRecord(traceId, annotation) {\n      var timestamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : now$1(this._startTimestamp, this._startTick);\n      this.recorder.record(new record({\n        traceId: traceId,\n        timestamp: timestamp,\n        annotation: annotation\n      }));\n    } // creates a span, timing the given callable, adding any error as a tag\n    // if the callable returns a promise, a span stops after the promise resolves\n\n  }, {\n    key: \"local\",\n    value: function local(operationName, callable) {\n      var _this = this;\n\n      if (typeof callable !== 'function') {\n        throw new Error('you must pass a function');\n      }\n\n      return this.scoped(function () {\n        var traceId = _this.createChildId();\n\n        _this.setId(traceId);\n\n        _this.recordServiceName(_this._localEndpoint.serviceName);\n\n        _this.recordAnnotation(new annotation_1.LocalOperationStart(operationName));\n\n        var result;\n\n        try {\n          result = callable();\n        } catch (err) {\n          _this.recordBinary('error', err.message ? err.message : err.toString());\n\n          _this.recordAnnotation(new annotation_1.LocalOperationStop());\n\n          throw err;\n        } // Finish the span on a synchronous success\n\n\n        if (!isPromise_1(result)) {\n          _this.recordAnnotation(new annotation_1.LocalOperationStop());\n\n          return result;\n        }\n\n        if (!traceId.sampled.getOrElse(false)) {\n          return result; // no need to stop as it was never started\n        } // At this point we know we are sampled. Explicitly record against the ID\n        // Ensure the span representing the promise completes\n\n\n        return result.then(function (output) {\n          _this._explicitRecord(traceId, new annotation_1.LocalOperationStop());\n\n          return output;\n        })[\"catch\"](function (err) {\n          var message = err.message ? err.message : err.toString();\n\n          _this._explicitRecord(traceId, new annotation_1.BinaryAnnotation('error', message));\n\n          _this._explicitRecord(traceId, new annotation_1.LocalOperationStop());\n\n          throw err;\n        });\n      });\n    }\n  }, {\n    key: \"join\",\n    value: function join(traceId) {\n      if (isUndefinedOrNull(traceId)) {\n        throw new Error('traceId is a required arg');\n      } // duck type check until we sort out a better way. We don't want to break\n      // transpiled usage ex. `traceId instanceof TraceId_1: false` See #422\n\n\n      if (isUndefinedOrNull(traceId._spanId)) {\n        throw new Error('Must be valid TraceId instance');\n      }\n\n      if (!this.supportsJoin) {\n        return this.createChildId(traceId);\n      }\n\n      if (traceId.sampled === None$2) {\n        /* eslint-disable no-param-reassign */\n        traceId._sampled = this.sampler.shouldSample(traceId);\n      } else {\n        /* eslint-disable no-param-reassign */\n        traceId._shared = true;\n      }\n\n      return traceId;\n    }\n  }, {\n    key: \"setId\",\n    value: function setId(traceId) {\n      this._ctxImpl.setContext(traceId);\n    } // Returns the current trace ID or a sentinel value indicating its absence.\n\n  }, {\n    key: \"recordAnnotation\",\n    value: function recordAnnotation(annotation, timestamp) {\n      if (this.id.sampled.getOrElse(false)) {\n        this._explicitRecord(this.id, annotation, timestamp);\n      }\n    }\n  }, {\n    key: \"recordMessage\",\n    value: function recordMessage(message) {\n      this.recordAnnotation(new annotation_1.Message(message));\n    }\n  }, {\n    key: \"recordServiceName\",\n    value: function recordServiceName(serviceName) {\n      this.recordAnnotation(new annotation_1.ServiceName(serviceName));\n    }\n  }, {\n    key: \"recordRpc\",\n    value: function recordRpc(name) {\n      this.recordAnnotation(new annotation_1.Rpc(name));\n    }\n  }, {\n    key: \"recordClientAddr\",\n    value: function recordClientAddr(ia) {\n      this.recordAnnotation(new annotation_1.ClientAddr(ia));\n    }\n  }, {\n    key: \"recordServerAddr\",\n    value: function recordServerAddr(ia) {\n      this.recordAnnotation(new annotation_1.ServerAddr(ia));\n    }\n  }, {\n    key: \"recordLocalAddr\",\n    value: function recordLocalAddr(ia) {\n      this.recordAnnotation(new annotation_1.LocalAddr(ia));\n    }\n  }, {\n    key: \"recordBinary\",\n    value: function recordBinary(key, value) {\n      this.recordAnnotation(new annotation_1.BinaryAnnotation(key, value));\n    }\n  }, {\n    key: \"writeIdToConsole\",\n    value: function writeIdToConsole(message) {\n      this.log.info(\"\".concat(message, \": \").concat(this.id.toString()));\n    }\n  }, {\n    key: \"setTags\",\n    value: function setTags() {\n      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // eslint-disable-next-line no-restricted-syntax\n\n      for (var tag in tags) {\n        if (Object.prototype.hasOwnProperty.call(tags, tag)) {\n          this.recordBinary(tag, tags[tag]);\n        }\n      }\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._ctxImpl.getContext() || this._sentinelTraceId;\n    }\n  }, {\n    key: \"localEndpoint\",\n    get: function get() {\n      return this._localEndpoint;\n    }\n  }]);\n\n  return Tracer;\n}();\n\nvar tracer = Tracer;\n\nvar explicitContext = /*#__PURE__*/function () {\n  function ExplicitContext() {\n    _classCallCheck(this, ExplicitContext);\n\n    this.currentCtx = null;\n  }\n\n  _createClass(ExplicitContext, [{\n    key: \"setContext\",\n    value: function setContext(ctx) {\n      this.currentCtx = ctx;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.currentCtx;\n    }\n  }, {\n    key: \"scoped\",\n    value: function scoped(callable) {\n      var prevCtx = this.getContext();\n\n      try {\n        return callable();\n      } finally {\n        this.setContext(prevCtx);\n      }\n    }\n  }, {\n    key: \"letContext\",\n    value: function letContext(ctx, callable) {\n      var _this = this;\n\n      return this.scoped(function () {\n        _this.setContext(ctx);\n\n        return callable();\n      });\n    }\n  }]);\n\n  return ExplicitContext;\n}();\n\nvar noop = function createNoopTracer() {\n  var recorder = {\n    record: function record() {}\n  };\n  var ctxImpl = new explicitContext();\n  return new tracer({\n    recorder: recorder,\n    ctxImpl: ctxImpl\n  });\n};\n\nvar httpHeaders = {\n  TraceId: 'X-B3-TraceId',\n  SpanId: 'X-B3-SpanId',\n  ParentSpanId: 'X-B3-ParentSpanId',\n  Sampled: 'X-B3-Sampled',\n  Flags: 'X-B3-Flags'\n};\nvar now$2 = time.now;\nvar Span$1 = model.Span,\n    Endpoint$2 = model.Endpoint;\n/**\n * defaultTags property name\n * @type {symbol}\n */\n\nvar defaultTagsSymbol = Symbol('defaultTags');\n\nfunction _timedOut(span) {\n  return span.timeoutTimestamp < now$2();\n}\n/**\n * @class PartialSpan\n */\n\n\nvar PartialSpan = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {TraceId} traceId\n   * @param {number} timeoutTimestamp (epoch in microseconds) after this moment, data\n   * should be forcibly flushed\n   */\n  function PartialSpan(traceId, timeoutTimestamp) {\n    _classCallCheck(this, PartialSpan);\n\n    this.traceId = traceId;\n    this.timeoutTimestamp = timeoutTimestamp;\n    this.delegate = new Span$1(traceId);\n    this.localEndpoint = new Endpoint$2({});\n    this.shouldFlush = false;\n  }\n  /**\n   * Conditionally records the duration of the span, if it has a timestamp.\n   *\n   * @param {number} finishTimestamp (epoch in microseconds) to calculate the duration from\n   */\n\n\n  _createClass(PartialSpan, [{\n    key: \"setDuration\",\n    value: function setDuration(finishTimestamp) {\n      if (this.shouldFlush) {\n        return;\n      }\n\n      this.shouldFlush = true; // even if we can't derive duration, we should report on finish\n\n      var startTimestamp = this.delegate.timestamp;\n\n      if (typeof startTimestamp === 'undefined') {\n        // We can't calculate duration without a start timestamp,\n        // but an annotation is better than nothing\n        this.delegate.addAnnotation(finishTimestamp, 'finish');\n      } else {\n        this.delegate.setDuration(finishTimestamp - startTimestamp);\n      }\n    }\n  }]);\n\n  return PartialSpan;\n}();\n/**\n * default timeout = 60 seconds (in microseconds)\n * @type {number}\n */\n\n\nvar defaultTimeout = 60 * 1000000;\n/**\n * @class BatchRecorder\n */\n\nvar BatchRecorder = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {Logger} options.logger logs the data to zipkin server\n   * @param {number} options.timeout timeout after which an unfinished span\n   * is flushed to zipkin in **microseconds**. Passing this value has\n   * implications in the reported data of the span so we discourage users\n   * to pass a value for it unless there is a good reason for.\n   */\n  function BatchRecorder(_ref) {\n    var _this = this;\n\n    var logger = _ref.logger,\n        _ref$timeout = _ref.timeout,\n        timeout = _ref$timeout === void 0 ? defaultTimeout : _ref$timeout;\n\n    _classCallCheck(this, BatchRecorder);\n\n    this.logger = logger;\n    this.timeout = timeout;\n    /**\n     * @type Map<string, PartialSpan>\n     */\n\n    this.partialSpans = new Map();\n    this[defaultTagsSymbol] = {}; // read through the partials spans regularly\n    // and collect any timed-out ones\n\n    var timer = setInterval(function () {\n      _this.partialSpans.forEach(function (span, id) {\n        if (_timedOut(span)) {\n          // the zipkin-js.flush annotation makes it explicit that\n          // the span has been reported because of a timeout, even\n          // when it is not finished yet (and thus enqueued for reporting)\n          span.delegate.addAnnotation(now$2(), 'zipkin-js.flush');\n\n          _this._writeSpan(id, span);\n        }\n      });\n    }, 1000); // every second, this will flush to zipkin any spans that have timed out\n\n    if (timer.unref) {\n      // unref might not be available in browsers\n      timer.unref(); // Allows Node to terminate instead of blocking on timer\n    }\n  }\n\n  _createClass(BatchRecorder, [{\n    key: \"_addDefaultTagsAndLocalEndpoint\",\n    value: function _addDefaultTagsAndLocalEndpoint(span) {\n      var defaultTags = this[defaultTagsSymbol]; // eslint-disable-next-line no-restricted-syntax\n\n      for (var tag in defaultTags) {\n        if (Object.prototype.hasOwnProperty.call(defaultTags, tag)) {\n          span.delegate.putTag(tag, defaultTags[tag]);\n        }\n      }\n\n      span.delegate.setLocalEndpoint(span.localEndpoint);\n    }\n  }, {\n    key: \"_writeSpan\",\n    value: function _writeSpan(id,\n    /** @type PartialSpan */\n    span) {\n      var isNew = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // TODO(adriancole) refactor so this responsibility isn't in writeSpan\n\n      if (!isNew && typeof this.partialSpans.get(id) === 'undefined') {\n        // Span not found. Could have been expired.\n        return;\n      } // ready for garbage collection\n\n\n      this.partialSpans[\"delete\"](id);\n      var spanToWrite = span.delegate; // Only add default tags and local endpoint on the first report of a span\n\n      if (span.delegate.timestamp) {\n        this._addDefaultTagsAndLocalEndpoint(span);\n      }\n\n      this.logger.logSpan(spanToWrite);\n    }\n  }, {\n    key: \"_updateSpanMap\",\n    value: function _updateSpanMap(id, timestamp, updater) {\n      var span;\n      var isNew = false; // we need to special case late finish annotations\n\n      if (this.partialSpans.has(id)) {\n        span = this.partialSpans.get(id);\n      } else {\n        isNew = true;\n        span = new PartialSpan(id, timestamp + this.timeout);\n      }\n\n      updater(span);\n\n      if (span.shouldFlush) {\n        this._writeSpan(id, span, isNew);\n      } else {\n        this.partialSpans.set(id, span);\n      }\n    }\n    /**\n     * Calling this will flush any pending spans to the transport.\n     *\n     * Note: the transport itself may be batching, in such case you may need to flush that also.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _this2 = this;\n\n      this.partialSpans.forEach(function (span, id) {\n        _this2._writeSpan(id, span);\n      });\n    }\n  }, {\n    key: \"record\",\n    value: function record(rec) {\n      var id = rec.traceId;\n\n      this._updateSpanMap(id, rec.timestamp, function (\n      /** @type PartialSpan */\n      span) {\n        switch (rec.annotation.annotationType) {\n          case 'ClientAddr':\n            span.delegate.setKind('SERVER');\n            span.delegate.setRemoteEndpoint(new Endpoint$2({\n              serviceName: rec.annotation.serviceName,\n              ipv4: rec.annotation.host && rec.annotation.host.ipv4(),\n              port: rec.annotation.port\n            }));\n            break;\n\n          case 'ClientSend':\n            span.delegate.setKind('CLIENT');\n            span.delegate.setTimestamp(rec.timestamp);\n            break;\n\n          case 'ClientRecv':\n            span.delegate.setKind('CLIENT');\n            span.setDuration(rec.timestamp);\n            break;\n\n          case 'ServerSend':\n            span.delegate.setKind('SERVER');\n            span.setDuration(rec.timestamp);\n            break;\n\n          case 'ServerRecv':\n            span.delegate.setShared(id.isShared());\n            span.delegate.setKind('SERVER');\n            span.delegate.setTimestamp(rec.timestamp);\n            break;\n\n          case 'ProducerStart':\n            span.delegate.setKind('PRODUCER');\n            span.delegate.setTimestamp(rec.timestamp);\n            break;\n\n          case 'ProducerStop':\n            span.delegate.setKind('PRODUCER');\n            span.setDuration(rec.timestamp);\n            break;\n\n          case 'ConsumerStart':\n            span.delegate.setKind('CONSUMER');\n            span.delegate.setTimestamp(rec.timestamp);\n            break;\n\n          case 'ConsumerStop':\n            span.delegate.setKind('CONSUMER');\n            span.setDuration(rec.timestamp);\n            break;\n\n          case 'MessageAddr':\n            span.delegate.setRemoteEndpoint(new Endpoint$2({\n              serviceName: rec.annotation.serviceName,\n              ipv4: rec.annotation.host && rec.annotation.host.ipv4(),\n              port: rec.annotation.port\n            }));\n            break;\n\n          case 'LocalOperationStart':\n            span.delegate.setName(rec.annotation.name);\n            span.delegate.setTimestamp(rec.timestamp);\n            break;\n\n          case 'LocalOperationStop':\n            span.setDuration(rec.timestamp);\n            break;\n\n          case 'Message':\n            span.delegate.addAnnotation(rec.timestamp, rec.annotation.message);\n            break;\n\n          case 'Rpc':\n            span.delegate.setName(rec.annotation.name);\n            break;\n\n          case 'ServiceName':\n            span.localEndpoint.setServiceName(rec.annotation.serviceName);\n            break;\n\n          case 'BinaryAnnotation':\n            span.delegate.putTag(rec.annotation.key, rec.annotation.value);\n            break;\n\n          case 'LocalAddr':\n            span.localEndpoint.setIpv4(rec.annotation.host && rec.annotation.host.ipv4());\n            span.localEndpoint.setPort(rec.annotation.port);\n            break;\n\n          case 'ServerAddr':\n            span.delegate.setKind('CLIENT');\n            span.delegate.setRemoteEndpoint(new Endpoint$2({\n              serviceName: rec.annotation.serviceName,\n              ipv4: rec.annotation.host && rec.annotation.host.ipv4(),\n              port: rec.annotation.port\n            }));\n            break;\n\n          default:\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"setDefaultTags\",\n    value: function setDefaultTags(tags) {\n      this[defaultTagsSymbol] = tags;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // eslint-disable-line class-methods-use-this\n      return 'BatchRecorder()';\n    }\n  }]);\n\n  return BatchRecorder;\n}();\n\nvar batchRecorder = BatchRecorder;\n/**\n * @class ConsoleRecorder\n */\n\nvar ConsoleRecorder = /*#__PURE__*/function () {\n  /* eslint-disable no-console */\n  function ConsoleRecorder() {\n    var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : console.log;\n\n    _classCallCheck(this, ConsoleRecorder);\n\n    this.logger = logger;\n  }\n\n  _createClass(ConsoleRecorder, [{\n    key: \"record\",\n    value: function record(rec) {\n      var _rec$traceId = rec.traceId,\n          spanId = _rec$traceId.spanId,\n          parentId = _rec$traceId.parentId,\n          traceId = _rec$traceId.traceId;\n      this.logger(\"Record at (timestamp=\".concat(rec.timestamp, \", spanId=\").concat(spanId, \", parentId=\").concat(parentId, \", \") + \"traceId=\".concat(traceId, \"): \").concat(rec.annotation.toString()));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      // eslint-disable-line class-methods-use-this\n      return 'consoleTracer';\n    }\n  }]);\n\n  return ConsoleRecorder;\n}();\n\nvar consoleRecorder = ConsoleRecorder;\n\nfunction parseRequestUrl(requestUrl) {\n  var parsed = url.parse(requestUrl);\n  return {\n    host: parsed.hostname,\n    path: parsed.pathname\n  };\n}\n\nvar parseUrl = parseRequestUrl;\nvar Some$4 = option.Some,\n    None$3 = option.None;\n\nfunction stringToBoolean(str) {\n  return str === '1' || str === 'true';\n}\n\nfunction stringToIntOption(str) {\n  try {\n    return new Some$4(parseInt(str));\n  } catch (err) {\n    return None$3;\n  }\n}\n\nfunction containsRequiredHeaders(readHeader) {\n  return readHeader(httpHeaders.TraceId) !== None$3 && readHeader(httpHeaders.SpanId) !== None$3;\n}\n\nfunction requiredArg$1(name) {\n  throw new Error(\"HttpServerInstrumentation: Missing required argument \".concat(name, \".\"));\n}\n\nvar HttpServerInstrumentation = /*#__PURE__*/function () {\n  function HttpServerInstrumentation(_ref) {\n    var _ref$tracer = _ref.tracer,\n        tracer = _ref$tracer === void 0 ? requiredArg$1('tracer') : _ref$tracer,\n        _ref$serviceName = _ref.serviceName,\n        serviceName = _ref$serviceName === void 0 ? tracer.localEndpoint.serviceName : _ref$serviceName,\n        host = _ref.host,\n        _ref$port = _ref.port,\n        port = _ref$port === void 0 ? requiredArg$1('port') : _ref$port;\n\n    _classCallCheck(this, HttpServerInstrumentation);\n\n    this.tracer = tracer;\n    this.serviceName = serviceName;\n    this.host = host && new InetAddress_1(host);\n    this.port = port;\n  }\n\n  _createClass(HttpServerInstrumentation, [{\n    key: \"_createIdFromHeaders\",\n    value: function _createIdFromHeaders(readHeader) {\n      if (containsRequiredHeaders(readHeader)) {\n        var spanId = readHeader(httpHeaders.SpanId);\n        var parentId = spanId.map(function (sid) {\n          var traceId = readHeader(httpHeaders.TraceId);\n          var parentSpanId = readHeader(httpHeaders.ParentSpanId);\n          var sampled = readHeader(httpHeaders.Sampled);\n          var flags = readHeader(httpHeaders.Flags).flatMap(stringToIntOption).getOrElse(0);\n          return new TraceId_1({\n            traceId: traceId.getOrElse(),\n            parentId: parentSpanId,\n            spanId: sid,\n            debug: flags === 1,\n            sampled: sampled.map(stringToBoolean)\n          });\n        });\n        return new Some$4(this.tracer.join(parentId.getOrElse()));\n      } else if (readHeader(httpHeaders.Flags) !== None$3 || readHeader(httpHeaders.Sampled) !== None$3) {\n        var sampled = readHeader(httpHeaders.Sampled) === None$3 ? None$3 : readHeader(httpHeaders.Sampled).map(stringToBoolean);\n        var flags = readHeader(httpHeaders.Flags).flatMap(stringToIntOption).getOrElse(0);\n        return new Some$4(this.tracer.createRootId(sampled, flags === 1));\n      } else {\n        return new Some$4(this.tracer.createRootId());\n      }\n    }\n  }, {\n    key: \"spanNameFromRoute\",\n    value: function spanNameFromRoute(method, route, code) {\n      // eslint-disable-line class-methods-use-this\n      if (code > 299 && code < 400) return \"\".concat(method, \" redirected\");\n      if (code === 404) return \"\".concat(method, \" not_found\");\n      if (!route || route === '') return method;\n      return \"\".concat(method, \" \").concat(route);\n    }\n  }, {\n    key: \"recordRequest\",\n    value: function recordRequest(method, requestUrl, readHeader) {\n      var _this = this;\n\n      this._createIdFromHeaders(readHeader).ifPresent(function (id) {\n        return _this.tracer.setId(id);\n      });\n\n      var id = this.tracer.id;\n\n      var _parseRequestUrl = parseUrl(requestUrl),\n          path = _parseRequestUrl.path;\n\n      this.tracer.recordServiceName(this.serviceName);\n      this.tracer.recordRpc(method.toUpperCase());\n      this.tracer.recordBinary('http.path', path);\n      this.tracer.recordAnnotation(new annotation_1.ServerRecv());\n      this.tracer.recordAnnotation(new annotation_1.LocalAddr({\n        host: this.host,\n        port: this.port\n      }));\n      return id;\n    }\n  }, {\n    key: \"recordResponse\",\n    value: function recordResponse(id, statusCode, error) {\n      this.tracer.setId(id);\n      this.tracer.recordBinary('http.status_code', statusCode.toString());\n\n      if (error) {\n        this.tracer.recordBinary('error', error.toString());\n      } else if (statusCode < 200 || statusCode > 399) {\n        this.tracer.recordBinary('error', statusCode.toString());\n      }\n\n      this.tracer.recordAnnotation(new annotation_1.ServerSend());\n    }\n  }]);\n\n  return HttpServerInstrumentation;\n}();\n\nvar httpServer = HttpServerInstrumentation;\n\nfunction appendZipkinHeaders(req, traceId) {\n  var headers = req.headers || {};\n  headers[httpHeaders.TraceId] = traceId.traceId;\n  headers[httpHeaders.SpanId] = traceId.spanId;\n  traceId.parentSpanId.ifPresent(function (psid) {\n    headers[httpHeaders.ParentSpanId] = psid;\n  });\n  traceId.sampled.ifPresent(function (sampled) {\n    headers[httpHeaders.Sampled] = sampled ? '1' : '0';\n  });\n\n  if (traceId.isDebug()) {\n    headers[httpHeaders.Flags] = '1';\n  }\n\n  return headers;\n}\n\nfunction addZipkinHeaders(req, traceId) {\n  var headers = appendZipkinHeaders(req, traceId);\n  return Object.assign({}, req, {\n    headers: headers\n  });\n}\n\nvar request = {\n  addZipkinHeaders: addZipkinHeaders\n};\n\nfunction requiredArg$2(name) {\n  throw new Error(\"HttpClientInstrumentation: Missing required argument \".concat(name, \".\"));\n}\n\nvar HttpClientInstrumentation = /*#__PURE__*/function () {\n  function HttpClientInstrumentation(_ref) {\n    var _ref$tracer = _ref.tracer,\n        tracer = _ref$tracer === void 0 ? requiredArg$2('tracer') : _ref$tracer,\n        _ref$serviceName = _ref.serviceName,\n        serviceName = _ref$serviceName === void 0 ? tracer.localEndpoint.serviceName : _ref$serviceName,\n        remoteServiceName = _ref.remoteServiceName;\n\n    _classCallCheck(this, HttpClientInstrumentation);\n\n    this.tracer = tracer;\n    this.serviceName = serviceName;\n    this.remoteServiceName = remoteServiceName;\n  }\n\n  _createClass(HttpClientInstrumentation, [{\n    key: \"recordRequest\",\n    value: function recordRequest(request$$1, url$$1, method) {\n      this.tracer.setId(this.tracer.createChildId());\n      var traceId = this.tracer.id;\n\n      var _parseRequestUrl = parseUrl(url$$1),\n          path = _parseRequestUrl.path;\n\n      this.tracer.recordServiceName(this.serviceName);\n      this.tracer.recordRpc(method.toUpperCase());\n      this.tracer.recordBinary('http.path', path);\n      this.tracer.recordAnnotation(new annotation_1.ClientSend());\n\n      if (this.remoteServiceName) {\n        // TODO: can we get the host and port of the http connection?\n        this.tracer.recordAnnotation(new annotation_1.ServerAddr({\n          serviceName: this.remoteServiceName\n        }));\n      }\n\n      return request.addZipkinHeaders(request$$1, traceId);\n    }\n  }, {\n    key: \"recordResponse\",\n    value: function recordResponse(traceId, statusCode) {\n      this.tracer.setId(traceId);\n      this.tracer.recordBinary('http.status_code', statusCode.toString());\n\n      if (statusCode < 200 || statusCode > 399) {\n        this.tracer.recordBinary('error', statusCode.toString());\n      }\n\n      this.tracer.recordAnnotation(new annotation_1.ClientRecv());\n    }\n  }, {\n    key: \"recordError\",\n    value: function recordError(traceId, error) {\n      this.tracer.setId(traceId);\n      this.tracer.recordBinary('error', error.toString());\n      this.tracer.recordAnnotation(new annotation_1.ClientRecv());\n    }\n  }]);\n\n  return HttpClientInstrumentation;\n}();\n\nvar httpClient = HttpClientInstrumentation;\nvar instrumentation = {\n  HttpServer: httpServer,\n  HttpClient: httpClient\n};\n\nfunction toV1Endpoint(endpoint) {\n  if (endpoint === undefined) {\n    return undefined;\n  }\n\n  var res = {\n    serviceName: endpoint.serviceName || '' // undefined is not allowed in v1\n\n  };\n\n  if (endpoint.ipv4) {\n    res.ipv4 = endpoint.ipv4;\n  }\n\n  if (endpoint.port) {\n    res.port = endpoint.port;\n  }\n\n  return res;\n}\n\nfunction toV1Annotation(ann, endpoint) {\n  return {\n    value: ann.value,\n    timestamp: ann.timestamp,\n    endpoint: endpoint\n  };\n}\n\nfunction encodeV1(span) {\n  var res = {\n    traceId: span.traceId\n  };\n\n  if (span.parentId) {\n    // instead of writing \"parentId\": NULL\n    res.parentId = span.parentId;\n  }\n\n  res.id = span.id;\n  res.name = span.name || ''; // undefined is not allowed in v1\n  // Log timestamp and duration if this tracer started and completed this span.\n\n  if (!span.shared) {\n    res.timestamp = span.timestamp;\n    res.duration = span.duration;\n  }\n\n  var jsonEndpoint = toV1Endpoint(span.localEndpoint);\n  var beginAnnotation;\n  var endAnnotation;\n  var addressKey;\n\n  switch (span.kind) {\n    case 'CLIENT':\n      beginAnnotation = span.timestamp ? 'cs' : undefined;\n      endAnnotation = 'cr';\n      addressKey = 'sa';\n      break;\n\n    case 'SERVER':\n      beginAnnotation = span.timestamp ? 'sr' : undefined;\n      endAnnotation = 'ss';\n      addressKey = 'ca';\n      break;\n\n    case 'PRODUCER':\n      beginAnnotation = span.timestamp ? 'ms' : undefined;\n      endAnnotation = 'ws';\n      addressKey = 'ma';\n      break;\n\n    case 'CONSUMER':\n      if (span.timestamp && span.duration) {\n        beginAnnotation = 'wr';\n        endAnnotation = 'mr';\n      } else if (span.timestamp) {\n        beginAnnotation = 'mr';\n      }\n\n      addressKey = 'ma';\n      break;\n\n    default:\n  }\n\n  if (span.annotations.length > 0 || beginAnnotation) {\n    // don't write empty array\n    res.annotations = span.annotations.map(function (ann) {\n      return toV1Annotation(ann, jsonEndpoint);\n    });\n  }\n\n  if (beginAnnotation) {\n    res.annotations.push({\n      value: beginAnnotation,\n      timestamp: span.timestamp,\n      endpoint: jsonEndpoint\n    });\n\n    if (span.duration) {\n      res.annotations.push({\n        value: endAnnotation,\n        timestamp: span.timestamp + span.duration,\n        endpoint: jsonEndpoint\n      });\n    }\n  }\n\n  var keys = Object.keys(span.tags);\n\n  if (keys.length > 0 || span.remoteEndpoint) {\n    // don't write empty array\n    res.binaryAnnotations = keys.map(function (key) {\n      return {\n        key: key,\n        value: span.tags[key],\n        endpoint: jsonEndpoint\n      };\n    });\n  }\n\n  if (span.remoteEndpoint) {\n    var address = {\n      key: addressKey,\n      value: true,\n      endpoint: toV1Endpoint(span.remoteEndpoint)\n    };\n    res.binaryAnnotations.push(address);\n  }\n\n  if (span.debug) {\n    // instead of writing \"debug\": false\n    res.debug = true;\n  }\n\n  return JSON.stringify(res);\n}\n\nfunction encodeV2(span) {\n  var copy = {\n    traceId: span.traceId\n  };\n\n  if (span.parentId) {\n    copy.parentId = span.parentId;\n  }\n\n  copy.id = span.id;\n\n  if (span.name) {\n    copy.name = span.name;\n  }\n\n  if (span.kind) {\n    copy.kind = span.kind;\n  }\n\n  if (span.timestamp) {\n    copy.timestamp = span.timestamp;\n  }\n\n  if (span.duration) {\n    copy.duration = span.duration;\n  }\n\n  if (span.localEndpoint) {\n    copy.localEndpoint = span.localEndpoint;\n  }\n\n  if (span.remoteEndpoint) {\n    copy.remoteEndpoint = span.remoteEndpoint;\n  }\n\n  if (span.annotations.length > 0) {\n    copy.annotations = span.annotations;\n  }\n\n  if (Object.keys(span.tags).length > 0) {\n    copy.tags = span.tags;\n  }\n\n  if (span.debug) {\n    copy.debug = true;\n  }\n\n  if (span.shared) {\n    copy.shared = true;\n  }\n\n  return JSON.stringify(copy);\n}\n\nvar JSON_V1 = {\n  encode: function encode(span) {\n    return encodeV1(span);\n  }\n};\nvar JSON_V2 = {\n  encode: function encode(span) {\n    return encodeV2(span);\n  }\n};\nvar jsonEncoder = {\n  JSON_V1: JSON_V1,\n  JSON_V2: JSON_V2\n};\nexport { option, annotation_1 as Annotation, tracer as Tracer, noop as createNoopTracer, randomTraceId_1 as randomTraceId, sampler, TraceId_1 as TraceId, httpHeaders as HttpHeaders, InetAddress_1 as InetAddress, batchRecorder as BatchRecorder, consoleRecorder as ConsoleRecorder, explicitContext as ExplicitContext, instrumentation as Instrumentation, request as Request, jsonEncoder, model, parseUrl as parseRequestUrl };","map":null,"metadata":{},"sourceType":"module"}